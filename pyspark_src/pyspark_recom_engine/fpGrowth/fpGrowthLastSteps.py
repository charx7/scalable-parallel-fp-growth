import json
import pandas as pd
import itertools


### It will create a list of dictionaries for all the possible path for a particular item
### The key in the dictionary is path and value is the frequency.
def find_values(id, json_repr):
    results = []
    finalResult = []

    def _decode_dict(a_dict):
        try: results.append(a_dict[id])
        except KeyError: pass
        return a_dict

    json.loads(json_repr, object_hook=_decode_dict)  # Return value ignored.
    
    for i in results:
        finalResult.append({i["parentTree"]:i["freq"]})
    
    return finalResult

### It will call the find_values function for all the items in the itemSupportTable
# It will store all the possible patterns in the data frame for a particular item.
def generateConditionalPatternBase(itemSupportTable,treeString):
    conditionalPatternBaseTable = pd.DataFrame(columns=['item','ConditionalPattern'])
    for itemset in itemSupportTable['item']:
        conditionalPatternBaseTable['item'] = itemset
        conditionalPatternBaseTable['ConditionalPattern'] = find_values(itemset,treeString)


#### This is generic function which I had written for generating Powerset to test ['K','E','M','O','Y']
### Will write the function to generate the powersets and group it as we discussed for FP-Growth.
def powerset(iterable):
    if len(iterable) == 1:
        return iterable
    listOfPowerSets=[]
    for L in range(1, len(iterable)+1):
        for subset in itertools.combinations(iterable, L):
            listOfPowerSets.append(subset)
    
    return listOfPowerSets

### This function will generate the data frame for all the rules which satisfies the confidenct threshold value.
### It takes the itemSupportTable which will also contain the possible pattern which will be generated by 
### Powerset function along with the single item frequency which we created in the 1st step
def generate_association_rules(itemSupportTable, confidence_threshold):
    rules = pd.DataFrame(columns=['boughtItem','suggestedItem','confidence'])
    for itemset in itemSupportTable['item']:
        union_support = itemSupportTable[support]

        for i in range(1, len(itemset)):
            for boughtItem in itertools.combinations(itemset, i):
                boughtItem = tuple(sorted(boughtItem))
                suggestedItem = tuple(sorted(set(itemset) - set(boughtItem)))

                if boughtItem in itemSupportTable['item']:
                    support = itemSupportTable.loc[itemSupportTable['item'] == boughtItem,'item'].iloc[0]
                    confidence = float(union_support) / support

                    if confidence >= confidence_threshold:
                        rules['boughtItem','suggestedItem','confidence'] = [boughtItem,suggestedItem,confidence]
                        

    return rules



